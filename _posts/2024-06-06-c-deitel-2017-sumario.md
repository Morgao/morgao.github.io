---
layout: post
title: C# Deitel 2017 Sumario
date: 2024-06-02 16:47
author: Morgao
comments: true
categories: [Curiosidades]
---
<!-- wp:paragraph -->
<p>C# Deitel 2017</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before You Begin<br>Introduction<br>1.1 Introduction<br>1.2 Object Technology: A Brief Review<br>1.3 C#<br>1.3.1 Object-Oriented Programming<br>1.3.2. Event-Driven Programming<br>1.3.3. Visual Programming<br>1.3.4 Generic and Functional Programming<br>1.3.5 An International Standard<br>1.3.6 C# on Non-Windows Platforms<br>1.3.7 Internet and Web Programming<br>1.3.8 Asynchronous Programming with async and await<br>14 Microsoft's .NET<br>14.1 .NET Framework<br>1.4.2 Common Language Runtime<br>1.4.3 Platform Independence<br>1.4.4 Language Interoperability<br>1.5 Microsoft’s Windows” Operating System<br>1.6 — Visual Studio Integrated Development Environment<br>1.7 — Painter Test-Drive in Visual Studio Community</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2 Introduction to Visual Studio and Visual Programming<br>2.1 Introduction<br>2.2. Overview of the Visual Studio Community 2015 IDE<br>2.2.1 Introduction to Visual Studio Community 2015<br>2.2.2 Visual Studio Themes<br>2.2.3. Links on the Start Page<br>2.2.4 Creating a New Project<br>2.2.5. New Project Dialog and Project Templates<br>2.2.6 Forms and Controls<br>2.3 Menu Bar and Toolbar<br>2.4 Navigating the Visual Studio IDE<br>2.4.1. Solution Explorer<br>2.4.2 Toolbox<br>2.4.3 Properties Window<br>2.5 Help Menu and Conrext-Sensitive Help<br>2.6 Visual Programming: Creating a Simple App that Displays ‘Text and an Image<br>2.7 Wrap-Up<br>2.8 Web Resources</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>3.0 Introduction to C# App Programming<br>3.1 Introduction<br>3.2 Simple App: Displaying a Line of Text<br>3.2.1 Comments<br>3.2.2. using Directive<br>3.2.3 Blank Lines and Whitespace<br>3.2.4 Class Declaration<br>3.2.5 Main Method<br>3.2.6 Displaying a Line of Text<br>3.2.7 Matching Left ({) and Right (+) Braces<br>3.3 Creating a Simple App in Visual Studio<br>3.3.1 Creating the Console App<br>3.3.2 Changing the Name of the App File<br>3.3.3. Writing Code and Using /ntelliSense<br>3.3.4 Compiling and Running the App<br>3.3.5 Errors, Error Messages and the Error List Window<br>3.4 Modifying Your Simple C# App<br>3.4.1 Displaying a Single Line of Text with Multiple Statements<br>3.4.2. Displaying Multiple Lines of Text with a Single Statement<br>3.5 String Interpolation<br>3.6 Another C# App: Adding Integers<br>3.6.1 Declaring the int Variable number1<br>3.6.2 Declaring Variables number2 and sum<br>3.6.3. Prompting the User for Input<br>3.6.4 Reading a Value into Variable number1<br>3.6.5 Prompting the User for Input and Reading a Value into number2<br>3.6.6 Summing number1 and number2<br>3.6.7 Displaying the sum with string Interpolation<br>3.6.8 — Performing Calculations in Output Statements<br>3.7 Arithmetic<br>3.7.1 Arithmetic Expressions in Straight-Line Form<br>7.2 Parentheses for Grouping Subexpressions<br>3.7.3 Rules of Operator Precedence<br>3.8 Decision Making: Equality and Relational Operators<br>3.9 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>4 Introduction to Classes, Objects, Methods and strings<br>4.1 Intraduction<br>4.2 Test-Driving an Account Class<br>4.2.1 Instantiating an Object—Keyword new<br>4.2.2 Calling Class Account’s GetName Method<br>4.2.3 Inputting a Name from the User<br>4.2.4 Calling Class Account’s SetName Method<br>4.3 Account Class with an Instance Variable and Set and Get Methods<br>4.3.1 Account Class Declaration<br>4.3.2 Keyword class and the Class Body<br>4.3.3 Instance Variable name of Type string<br>4.3.4 SetName Method<br>4.3.5 GetName Method<br>4.3.6 Access Modifiers private and public<br>4.3.7 Account UML Class Diagram<br>4.4 Creating, Compiling and Running a Visual C# Project with Two Classes<br>4.5 Software Engineering with Set and Ger Methods<br>4.6 Account Class with a Property Rather Than Set and Get Methods<br>4.6.1 Class AccountTest Using Account’s Name Property<br>4.6.2. Account Class with an Instance Variable and a Property<br>4.6.3 Account UML Class Diagram with a Property<br>4.7 Auto-Implemented Properties<br>4.8 Account Class: Initializing Objects with Constructors<br>4.8.1 Declaring an Account Constructor for Custom Object Initialization<br>4.8.2 Class AccountTest: Initializing Account Objects When<br>They're Created<br>4.9 Account Class with a Balance; Processing Monetary Amounts<br>4.9.1 Account Class with a decimal balance Instance Variable<br>4.9.2 AccountTest Class That Uses Account Objects with Balances<br>4.10 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>5 Control Statements: Part |<br>5.1 Intraduction<br>5.2 Control Structures<br>5.2.1 Sequence Structure<br>5.2.2 Selection Statements<br>5.2.3 Iteration Statements<br>5.2.4 Summary of Control Statements<br>5.3 if Single-Selection Statement<br>5.4 if…else Double-Selection Statement<br>5.4.1 Nested if…else Statements<br>5.4.2 Dangling-else Problem<br>5.4.5. Blocks 102<br>5.4.4 Conditional Operator (?:) 103<br>5.5 Student Class: Nested if…e1se Statements 103<br>5.6 while Iteration Statement 106<br>4.7 Counter-Controlled Iteration 107<br>5.7.1 Implementing Counter-Controlled Iteration 108<br>5.7.2 Integer Division and Truncation 110<br>5.8 Sentinel-Controlled Iteration 110<br>5.8.1 Implementing Sentinel-Controlled Iteration 110<br>5.8.2 Program Logic for Sentinel-Controlled Iteration 112<br>5.8.3 Braces in a while Statement 113<br>5.8.4 Converting Between Simple Types Explicitly and Lmplicitly 113<br>5.8.5 Formatting Floating-Point Numbers 114<br>5.9 Nested Control Statements 114<br>5.10 Compound Assignment Operators 117<br>5.11 Increment and Decrement Operators 118<br>5.11.1 Prefix Increment vs. Postfix Increment 119<br>5.11.2 Simplifying Increment Statements 120<br>5.11.3 Operator Precedence and Associativity 120<br>5.12 Simple Types 121<br>5.13 Wrap-Up 121</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>6 Control Statements: Part 2 123<br>6.1 Introduction 124<br>6.2 Essentials of Counter-Controlled Iteration 124<br>6.3 for lteration Statement 135<br>6.3.1 A Closer Look at the for Statement’s Header 126<br>6.3.2 General Format of a for Statement 126<br>6.3.3. Scope of a for Statement’s Control Variable 127<br>6.3.4 Expressions in a for Statement’s Header Are Optional 127<br>6.3.5 UML Activity Diagram for the for Statement 127<br>6.4 — App: Summing Even Integers 128<br>6.5 App: Compound-Interest Calculations 129<br>6.5.1 Performing the Interest Calculations with Math Method pow 130<br>6.5.2 Formatting with Field Widths and Alignment 131<br>6.5.3. Caution: Do Not Use float or double for Monetary Amounts 131<br>6.6 — do.,.while Iteration Statement 132<br>6.7 switch Multiple-Selection Statement 133<br>6.7.1 Using a switch Statement to Count A, B, C, D and F Grades 133<br>6.7.2 switch Statement UML Activity Diagram 138<br>6.7.3 Notes on the Expression in Each case of a switch 138<br>6.8 Class AutoPolicy Case Study: strings in switch Statements 139<br>6.9 break and continue Statements 141<br>6.9.1 break Statement 141<br>6.9.2. continue Statement 142<br>6.10 Logical Operators 143<br>6.10.1 Conditional AND (&amp;&amp;) Operator<br>6.10.2 Conditional OR (| |) Operator<br>6.10.3. Short-Circuit Evaluation of Complex Conditions<br>6.10.4 Boolean Logical AND (&amp;) and Boolean Logical OR (|) Operators<br>6.10.5 Boolean Logical Exclusive OR (4)<br>6.10.6 Logical Negation (!) Operator<br>6.10.7 Logical Operators Example<br>6.11 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>7 Methods: A Deeper Look<br>7.1 Introduction<br>7.2 Packaging Code in C#<br>7.3 static Methods, static Variables and Class Math<br>7.3.1 Math Class Methods<br>7.3.2 Math Class Constants PI and E<br>7.3.3 Why Is Main Declared static?<br>7.3.4 Additional Comments About Main<br>7.4 Methods with Multiple Parameters<br>7.4.1 Keyword static<br>7.4.2 Method Maximum<br>7.4.3 Assembling strings with Concatenation<br>7.4.4 Breaking Apart Large string Literals<br>7.4.5 When to Declare Variables as Fields<br>7.4.6 Implementing Method Maximum by Reusing Method Math .Max<br>7.5 Notes on Using Methods<br>7.6 Argument Promotion and Casting<br>7.6.1 Promotion Rules<br>7.6.2 Sometimes Explicit Casts Are Required<br>7.7 The .NET Framework Class Library<br>7.8 Case Study: Random-Number Generation<br>7.8.1 Creating an Object of Type Random<br>7.B.2 Generating a Random Integer<br>7.8.3 Scaling the Random-Number Range<br>7.8.4 Shifting Random-Number Range<br>7.8.5 Combining Shifting and Scaling<br>7.8.6 Rolling a Six-Sided Die<br>7.8.7 Scaling and Shifting Random Numbers<br>7.8.8 Repeatability for Testing and Debugging<br>7.9 Case Study: A Game of Chance; Introducing Enumerations<br>7.9.1 Method Rol1Dice<br>7.9.2 Method Main’s Local Variables<br>7.9.3 enum Type Status<br>7.9.4 The First Roll<br>7.9.5 enum Type DiceNames<br>7.9.6 Underlying Type of an enum<br>7.9.7 Comparing Integers and enum Constants<br>7.10 Scope of Declarations<br>7.11 Method-Call Stack and Activation Records<br>7.11.1 Method-Call Stack<br>7.11.2 Stack Frames<br>7.11.3 Local Variables and Stack Frames<br>7.11.4 Stack Overflow<br>7.11.5 Method-Call Stack in Action<br>7.12 Method Overloading<br>7.12.1 Declaring Overloaded Methods<br>7.12.2 Distinguishing Between Overloaded Methods<br>7.12.3. Return Types of Overloaded Methods<br>7.13 Optional Parameters<br>7.14 Named Parameters<br>7.15 C# 6 Expression-Bodied Methods and Properties Recursion<br>7.16.1 Base Cases and Recursive Calls<br>7.16.2 Recursive Factorial Calculations<br>7.16.3 Implementing Factorial Recursively Value Types vs. Reference Types<br>Passing Arguments By Value and By Reference<br>7.18.1 ref and out Parameters<br>7.18.2 Demonstrating ref, out and Value Parameters<br>7.19 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>8 Arrays; Introduction to Exception Handling<br>8.1 Introduction<br>8.2 Arrays<br>8.3 Declaring and Creating Arrays<br>8.4 Examples Using Arrays<br>8.4.1 Creating and Initializing an Array<br>8.4.2 Using an Array Initializer<br>8.4.3 Calculating a Value to Store in Each Array Element<br>8.4.4 Summing the Elements of an Array<br>8.4.5 — Iterating Through Arrays with foreach<br>8.4.6 Using Bar Charts to Display Array Data Graphically; Introducing Type Inference with var<br>8.4.7 Using the Elements of an Array as Counters<br>Using Arrays to Analyze Survey Results; Intro to Exception Handling<br>8.5.1 Summarizing the Results<br>8.5.2 Exception Handling: Processing the Incorrect Response<br>8.5.3 The try Statement<br>8.5.4 Executing the catch Block<br>8.5.5 | Message Property of the Exception Parameter<br>Case Study: Card Shuffling and Dealing Simulation<br>8.6.1 Class Card and Getter-Only Auto-Implemented Properties<br>8.6.2 Class DeckOfCards<br>8.6.3 Shuffling and Dealing Cards<br>8.7 Passing Arrays and Array Elements to Methods<br>8.8 Case Study: GradeBook Using an Array to Store Grades Multidimensional Arrays<br>8.9.1 Rectangular Arrays<br>8.9.2 Jagged Arrays<br>8.9.3. Two-Dimensional Array Example: Displaying Element Values<br>8.10 Case Study: GradeBook Using a Rectangular Array<br>8.11 Variable-Length Argument Lists<br>8.12 Using Command-Line Arguments<br>8.13 (Optional) Passing Arrays by Value and by Reference<br>8.14 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>9 Introduction to LINQ and the List Collection 245<br>9.1 Introduction<br>9.2 Querying an Array of int Values Using LINQ<br>9.2.1 The from Clause<br>9.2.2 The where Clause<br>9.2.4 The select Clause<br>9.2.4 Tterating Through the Results of the LINQ Query<br>9.2.5 The orderby Clause<br>9.2.6 Interface IEnumerable<br>9.3 Querying an Array of Employee Objects Using LINQ<br>9.3.1 Accessing the Properties of a LINQ Query’s Range Variable<br>9.3.2 Sorting a LINQ Query’s Results by Multiple Properties<br>9.3.3 Any, First and Count Extension Methods<br>9.3.4 Selecting a Property of an Object<br>9.3.5 Creating New Types in the select Clause of a LINQ Query<br>9.4 Intraduction to Collections<br>9.4.1 List Collection<br>9.4.2. Dynamically Resizing a List Collection Querying the Generic 9.5 List Collection Using LINQ<br>9.5.1 The let Clause<br>9.5.2 Deferred Execurion<br>9.5.3. Extension Methods ToArray and ToList<br>9.5.4 Collection Initializers<br>9.6 Wrap-Up<br>9.7 Deitel LINQ Resource Center</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>10 Classes and Objects: A Deeper Look</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true,"start":10} -->
<ol start="10"><!-- wp:list-item -->
<li>Introduction</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>10.2 Time Class Case Study; Throwing Exceptions<br>10.2.1 Timet Class Declaration<br>10.2.2 Using Class Time<br>10.3 Controlling Access to Members<br>10.4 Referring to the Current Object’s Members with the this Reference<br>10.5 Time Class Case Study: Overloaded Constructors<br>10.5.1 Class Time2 with Overloaded Constructors<br>10.5.2 Using Class Time2’s Overloaded Constructor<br>10.6 Default and Parameterless Constructors<br>10.7 Composition<br>10.7.1 Class Date<br>10.7.2 Class Employee<br>10.7.3 Class EmployeeTest<br>10.8 Garbage Collection and Destructors<br>10.9 static Class Members<br>10.10 readonly Instance Variables<br>10.11 Class View and Object Browser<br>10.11.1 Using the Class View Window<br>10.11.2 Using the Object Browser<br>10.12 Object Initializers<br>10.13 Operator Overloading; Introducing struct<br>10.13.1 Creating Value Types with struct<br>10.13.2. Value Type ComplexNumber<br>10.13.3 Class ComplexTest<br>10.14 Time Class Case Study: Extension Methods<br>10.15 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>11 Object-Oriented Programming: Inheritance<br>11.1 Intraduction<br>11.2 Base Classes and Derived Classes<br>11.3 protected Members<br>11.4 Relationship between Base Classes and Derived Classes<br>11.4.1 Creating and Using a CommissionEmployee Class<br>11.4.2 Creating a BasePlusCommi ssionEmployee Class withour<br>Using Inheritance<br>11.4.3. Creating a CommissionEmployee—BaseP1usCommi ssi onEmployee<br>Inheritance Hierarchy<br>11.4.4 CommissionEmployee—BasePlusCommissionEmployee Inheritance<br>Hierarchy Using protected Instance Variables<br>11.4.5 Commissi onEmployee—BasePlusCommissionEmployee Inheritance<br>Hierarchy Using private Instance Variables<br>11.5 Constructors in Derived Classes<br>11.6 Software Engineering with Inheritance<br>11.7 Class object<br>11.8 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>12 OOP: Polymorphism and Interfaces<br>12.1 Introduction<br>12.2 Polymorphism Examples<br>12.3 Demonstrating Polymorphic Behavior<br>12.4 Abstract Classes and Methods<br>12.5 Case Study: Payroll System Using Polymorphism<br>12.5.1 Creating Abstract Base Class Employee<br>12.5.2 Creating Concrete Derived Class SalariedEmployee<br>12.5.3 Creating Concrete Derived Class HourlyEmployee<br>12.5.4 Creating Concrete Derived Class CommissionEmployee<br>12.5.5 Creating Indirect Concrete Derived Class BasePlusCommissionEmployee<br>12.5.6 Polymorphic Processing, Operator is and Downcasting<br>12.5.7 Summary of the Allowed Assignments Between Base-Class and Derived-Class Variables<br>12.6 sealed Methods and Classes<br>12.7 Case Study: Creating and Using Interfaces<br>12.7.1 Developing an IPayable Hierarchy<br>12.7.2 Declaring Interface Payable<br>12.7.3. Creating Class Invoice<br>12.7.4 Modifying Class Employee to Implement Interface [Payable<br>12.7.5 Using Interface [Payable to Process Invoices and Employees<br>12.7.6 Common Interfaces of the .NET Framework Class Library<br>finally Block<br>Polymorphically<br>12.8 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>13 Exception Handling: A Deeper Look<br>13.1 Introduction<br>13.2 Example: Divide by Zero without Exception Handling<br>13.2.1 Dividing By Zero<br>13.2.2 Enter a Non-Numeric Denominator<br>13.2.3 Unhandled Exceptions Terminate the App<br>13.3 Example: Handling DivideByZeroExceptions and FormatExceptions<br>13.3.1 Enclosing Code in a try Block<br>13.3.2 Catching Exceptions<br>13.3.3 Uncaught Exceptions<br>13.3.4 Termination Model of Exception Handling<br>13.3.5 Flow of Control When Exceptions Occur<br>13.4 .NET Exception Hierarchy<br>13.4.1 Class SystemException<br>13.4.2 Which Exceptions Might a Method Throw?<br>13.5 finally Block<br>13.5.1 Moving Resource-Release Code to a finally Block<br>13.5.2 Demonstrating the finally Block<br>13.5.3 Throwing Exceptions Using the throw Statement<br>13.5.4 Rethrowing Exceptions<br>13.5.5 Returning After a finally Block<br>13.6 The using Statement<br>13.7 Exception Properties<br>13.7.1 Property InnerException<br>13.7.2. Other Exception Properties<br>13.7.3. Demonstrating Exception Properties and Stack Unwinding<br>13.7.4 Throwing an Exception with an InnerException<br>13.7.5 Displaying Information About the Exception<br>13.8 User-Defined Exception Classes<br>13.9 Checking for nu11 References; Introducing C# 6’s ?. Operator<br>13.9.1 Null-Conditional Operator (?.)<br>13.9.2 Revisiting Operators is and as<br>13.9.3. Nullable Types<br>13.9.4 Null Coalescing Operator (77)<br>13.10 Exception Filters and the C# 6 when Clause<br>13.11 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>14 Graphical User Interfaces with Windows Forms: Part |<br>14.1 Introduction<br>14.2 Windows Forms<br>14.3 Event Handling<br>14.3.1 A Simple Event-Driven GUI<br>14.3.2 Auto-Generated GUI Code<br>14.3.3. Delegates and the Event-Handling Mechanism<br>14.3.4 Another Way to Create Event Handlers<br>14.3.5 Locating Event Information<br>14.4 Control Properties and Layout<br>14.4.1 Anchoring and Docking<br>14.4.2. Using Visual Studio To Edir a GUI’s Layout<br>14.5 Labels, TextBoxes and Buttons<br>14.6 GroupBoxes and Panels<br>14.7 CheckBoxes and RadioButtons<br>14.7.1 CheckBoxes<br>14.7.2. Combining Font Styles with Bitwise Operators<br>14.7.3 RadioButtons<br>14.8 PictureBoxes<br>14.9 ToolTips<br>14.10 NumericUpDown Control<br>14.11 Mouse-Event Handling<br>14.12 Keyboard-Event Handling<br>14.13 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>15 raphical User Interfaces with Windows Forms: Part 2<br>15.1 Introduction<br>15.2. Menus<br>15.3. MonthCalendar Control<br>15.4 DatelimePicker Control<br>15.5 LinkLabel Control<br>15.6 ListBox Conrrol<br>15.7. CheckedListBox Control<br>15.8 ComboBox Control<br>15.9 TreeView Control<br>15.10 ListView Control<br>15.11 TabControl Control<br>15.12. Multiple Document Interface (MDI) Window<br>15.13 Visual Inheritance<br>15.14 User-Defined Controls<br>15.15 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>16 Strings and Characters: A Deeper Look<br>16.1 Introduction<br>16.2 Fundamentals of Characters and Strings<br>16.3. string Constructors<br>16.4 string Indexer, Length Property and CopyTo Method<br>16.5 Comparing strings<br>16.6 Locating Characters and Substrings in strings<br>16.7 Extracting Substrings from strings<br>16.8 Concatenating strings<br>16.9 Miscellaneous string Methods<br>16.10 Class StringBuilder<br>16.11 Length and Capacity Properties, EnsureCapacity Method and<br>Indexer of Class StringBuilder<br>16.12 Append and AppendFormat Methods of Class StringBuilder<br>16.13 Insert, Remove and Replace Methods of Class StringBuilder<br>16.14 Char Methods<br>16.15 Introduction to Regular Expressions (Online)<br>16.16 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>17 Files and Streams<br>17.1 Introduction<br>17.2 Files and Streams<br>17.3 Creating a Sequential-Access Text File<br>17.4 Reading Data from a Sequential-Access Text File<br>17.5 Case Study: Credit-Inquiry Program<br>17.6 Serialization<br>17.7 Creating a Sequential-Access File Using Object Serialization<br>17.8 Reading and Deserializing Data from a Binary File<br>17.9 Classes File and Directory<br>17.9.1 Demonstrating Classes File and Directory<br>17.9.2 Searching Directories with LINQ<br>17.10 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>18 Generics<br>18.1 Introduction<br>18.2 Motivation for Generic Methods<br>18.3 Generic-Method Implementation<br>18.4 Type Constraints<br>18.4.1 IComparable Interface<br>18.4.2 Specifying Type Constraints<br>18.5 Overloading Generic Methods<br>18.6 Generic Classes<br>18.7 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>19 Generic Collections; Functional Programming with LINQ/PLINQ<br>19.1Intreduction<br>19.2 Collections Overview<br>19.3 Class Array and Enumerators<br>19.3.1 C#G6 using static Directive<br>19.3.2. Class UsingArray’s static Fields<br>19.3.3. Array Method Sort<br>19.3.4 Array Method Copy<br>19.3.5 Array Method BinarySearch<br>19.3.6 Array Method GetEnumerator and Interface [Enumerator<br>19.3.7 Lterating Over a Collection with foreach<br>19.3.8 Array Methods Clear, IndexOf, LastIndexOf and Reverse<br>19.4 Dictionary Collections<br>19.4.1 Dictionary Fundamentals<br>19.4.2. Using the SortedDictionary Collection<br>19.5 Generic LinkedList Collection<br>19.6 C# 6 Null Conditional Operator ? []<br>19.7 C# 6 Dictionary Initializers and Collection Initializers<br>19.8 Delegates<br>19.8.1 Declaring a Delegate Type<br>19.8.2 Declaring a Delegate Variable<br>19.8.3 Delegate Parameters<br>19.8.4 Passing a Method Name Directly to a Delegate Parameter<br>19.9 Lambda Expressions<br>19.9.1 Expression Lambdas<br>19.9.2 Assigning Lambdas to Delegate Variables<br>19.9.3 Explicitly Typed Lambda Parameters<br>19.9.4 Statement Lambdas<br>19.10 Intreduction to Functional Programming<br>19.11 Functional Programming with LINQ Method-Call Syntax and Lambdas<br>19.11.1 LINQ Extension Methods Min, Max, Sum and Average<br>19.11.2 Aggregate Extension Method for Reduction Operations<br>19.11.3 The Where Extension Method for Filtering Operations<br>19.11.4 Select Exrension Method for Mapping Operations<br>19.12 PLINQ: Improving LINQ to Objects Performance with Multicore<br>19.13 (Optional) Covariance and Contravariance for Generic Types<br>19.14 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>20 Databases and LINQ<br>20.1 Introduction<br>20.2 Relational Databases<br>20.3 A Books Database<br>20.4 LINQ to Entities and the ADO.NET Entity Framework<br>20.5 Querying a Database with LINQ<br>20.5.1 Creating the ADO.NET Entity Data Model Class Library<br>20.5.2. Creating a Windows Forms Project and Configuring It to<br>Use the Entity Data Model<br>20.5.3 Data Bindings Between Controls and the Entity Data Model<br>20.6 Dynamically Binding Query Results<br>20.6.1 Creating the Display Query Results GUI<br>20.6.2 Coding the Display Query Results App<br>20.7 Retrieving Data from Multiple Tables with LINQ<br>20.8 Creating a Master/Detail View App<br>20.8.1 Creating the Master/Detail GUI<br>20.8.2 Coding the Master/Detail App<br>20.9 Address Book Case Study<br>20.9.1 Creating the Address Book App’s GUI<br>20.9.2 Coding the Address Book App<br>20.10 Tools and Web Resources<br>20.11 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>21 Asynchronous Programming with async and await<br>21.1 Introduction<br>21.2 Basics of async and await<br>21.2.1 async Modifier<br>21.2.2 await Expression<br>21.2.3 async, await and Threads<br>21.3 Executing an Asynchronous Task from a GUI App<br>21.3.1 Performing a Task Asynchronously<br>21.3.2 Method calculateButton_Click<br>21.3.3 Task Method Run: Executing Asynchronously in a Separate Thread<br>21.3.4 awaiting the Result<br>21.3.5 Calculating the Next Fibonacci Value Synchronously<br>21.4 Sequential Execution of Two Compute-Intensive Tasks<br>21.5 Asynchronous Execution of Two Compute-Lntensive Tasks<br>21.5.1 awaiting Multiple Tasks with Task Method WhenA11]<br>21.5.2) Method StartFibonacci<br>21.5.3. Modifying a GUI from a Separate Thread<br>21.5.4 awaiting One of Several Tasks with Task Method WhenAny<br>21.6 Invoking a Flickr Web Service Asynchronously with HttpC1ient<br>21.6.1 Using Class HttpClient to Invoke a Web Service<br>21.6.2. Invoking the Flickr Web Service's<br>flickr.photos.search Method<br>21.6.3 Processing the XML Response<br>21.6.4 Binding the Photo Titles to the ListBox<br>21.6.5 Asynchronously Downloading an Image’s Bytes<br>21.7 Displaying an Asynchronous Task’s Progress<br>21.8 Wrap-Up</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Apendice A Operator Precedence Chart<br>Apendice B Simple Types<br>Apendice C ASCII Character Set<br>book Index</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>‘</p>
<!-- /wp:paragraph -->
